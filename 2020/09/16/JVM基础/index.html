<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、JVM位置  JVM是运行在操作系统之上的，它与硬件没有直接的交互">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM基础">
<meta property="og:url" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Ale&#39;s Blog">
<meta property="og:description" content="一、JVM位置  JVM是运行在操作系统之上的，它与硬件没有直接的交互">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917105557649.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917111816718.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917164628426.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917182723256.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917160049799.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200918105002179.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200918140159017.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919145504023.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919163652763.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919172609276.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919204406923.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919205653431.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200920103058010.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200920103243250.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200920103315506.png">
<meta property="og:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200921195758140.png">
<meta property="article:published_time" content="2020-09-16T11:35:42.816Z">
<meta property="article:modified_time" content="2020-09-21T12:52:59.416Z">
<meta property="article:author" content="Leo-Fang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917105557649.png">

<link rel="canonical" href="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM基础 | Ale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/16/JVM%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Leo-Fang">
      <meta itemprop="description" content="记录学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ale's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-16 19:35:42" itemprop="dateCreated datePublished" datetime="2020-09-16T19:35:42+08:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-21 20:52:59" itemprop="dateModified" datetime="2020-09-21T20:52:59+08:00">2020-09-21</time>
              </span>

          
            <span id="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/" class="post-meta-item leancloud_visitors" data-flag-title="JVM基础" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="一、JVM位置"><a href="#一、JVM位置" class="headerlink" title="一、JVM位置"></a>一、JVM位置</h3><img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917105557649.png" class="">

<p>JVM是<strong>运行在操作系统之上</strong>的，它与硬件没有直接的交互</p>
<a id="more"></a>

<p>JVM体系结构概览</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917111816718.png" class="">

<p>注：</p>
<ul>
<li><p>平时所说的栈指的是Java栈</p>
</li>
<li><p>本地方法栈中装的都是native方法</p>
</li>
<li><p>方法区并不是存放方法的区域，而是存放类的描述信息（模板）的地方</p>
</li>
<li><p>运行时数据区中：</p>
<p>亮色的模块是所有线程共享的，存在垃圾回收；灰色的模块是线程私有的，且内存占用很少，几乎不存在GC垃圾回收</p>
</li>
</ul>
<h3 id="二、类装载器"><a href="#二、类装载器" class="headerlink" title="二、类装载器"></a>二、类装载器</h3><h4 id="什么是类装载器"><a href="#什么是类装载器" class="headerlink" title="什么是类装载器"></a>什么是类装载器</h4><p>负责加载class文件，class文件<strong>在文件开头有特定的文件标示</strong>（cafe babe），将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader<strong>只负责class文件的加载</strong>，至于它是否可以运行，则由Execution Engine决定。</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917164628426.png" class="">

<p>注：</p>
<ul>
<li>ClassLoader只是负责class文件的加载，ClassLoader有多种，相当于是一个“快递员”，快递员也是有多家</li>
<li>加载之前是小“class”，加载之后变成了大“Class”，这是一个模板。大“Class”就装载在方法区，模板实例化后就得到若干个对象</li>
<li>JVM并不是通过检查文件后缀是不是<code>.class</code>来判断是否需要加载的，而是通过文件开头的特定文件标志<code>cafe babe</code></li>
</ul>
<h4 id="类装载器的分类"><a href="#类装载器的分类" class="headerlink" title="类装载器的分类"></a>类装载器的分类</h4><ul>
<li><p>虚拟机自带的加载器</p>
<ul>
<li><p>启动类加载器（Bootstrap）（C++编写）</p>
<p>也叫根加载器，由原生代码编写，不继承自java.lang.ClassLoader。负责加载核心Java库，存储在&lt;JAVA_HOME&gt;/jre/lib目录中。</p>
</li>
<li><p>扩展类加载器（Extension）（Java编写）</p>
<p>用来在&lt;JAVA_HOME&gt;/jre/lib/ext或java.ext.dirs中指明的目录中加载Java的扩展库。Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里查找并加载Java类，该类由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>应用程序类加载器（AppClassLoader）</p>
<p>也叫系统类加载器，根据 Java应用程序的类路径（java.class.path或CLASSPATH环境变量）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。该类由sun.misc.Launcher$AppClassLoader实现。</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917182723256.png" class="">

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//        System.out.println(object.getClass().getClassLoader().getParent().getParent());</span></span><br><span class="line">        <span class="comment">//NullPointerException</span></span><br><span class="line"><span class="comment">//        System.out.println(object.getClass().getClassLoader().getParent());</span></span><br><span class="line">        <span class="comment">//NullPointerException</span></span><br><span class="line">        System.out.println(object.getClass().getClassLoader());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader().getParent().getParent());<span class="comment">//null</span></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader().getParent());</span><br><span class="line">        <span class="comment">//不同版本的JDK显示的结果也不一样</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@1b6d3586——JDK1.8</span></span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$PlatformClassLoader@48140564——JDK11</span></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户自定义加载器</p>
<p>java.lang.ClassLoader的子类，用户可以定制类的加载方式</p>
</li>
</ul>
<p>注：</p>
<ul>
<li>如果是JDK自带的类（Object、String、ArrayList等），使用的是启动类加载器；如果是用户自定义的类，使用的是应用程序类加载器；扩展类加载器是负责把Java更新的程序包的类加载进行</li>
<li>sun.misc.Launcher是JVM的一个入口应用</li>
<li>启动类加载器在后台打印的是null</li>
</ul>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>当一个类收到了类加载请求，首先它不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p>
<p>采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，<strong>不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象</strong>。</p>
<p>注：</p>
<ul>
<li><p>当需要用到一个A.java类，首先去顶层BootStrap启动类加载器找，找得到就用，找不到就到下一层Extension扩展类加载器找，找得到就用，找不到就再降一层，去AppClassLoader应用程序类加载器找，找得到就用，找不到就会报“ClassNotFoundException”</p>
</li>
<li><p>测试类加载器的顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****hello world******"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先使用的是启动类加载器，由于JVM中有java.lang.String这个类，所以会首先加载这个类，而不是自己写的这个“String”类，但JVM中的String类没有main方法，所以会报“在类 java.lang.String 中找不到 main 方法”。</p>
<p>这个问题涉及到如果有两个相同的类，那么Java会用哪一个？为了保证用户写的代码不污染Java自带的源代码，提供了一种“双亲委派”机制，保证“沙箱安全”，即先找到先用。</p>
</li>
</ul>
<h3 id="三、执行引擎"><a href="#三、执行引擎" class="headerlink" title="三、执行引擎"></a>三、执行引擎</h3><p>执行引擎负责解释命令，提交操作系统执行。</p>
<h3 id="四、本地方法接口与本地方法栈"><a href="#四、本地方法接口与本地方法栈" class="headerlink" title="四、本地方法接口与本地方法栈"></a>四、本地方法接口与本地方法栈</h3><p>本地方法接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。Java诞生之初是C/C++横行的时候，想要立足必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是本地方法栈（Native Method Stack）中登记native方法，在执行引擎（Execution Engine）执行时加载本地方法库（native libraries）。</p>
<p>目前该方法使用的越来越少，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p>
<p><strong>native方法都装在本地方法栈</strong>（Native Method Stack）中。native是关键字，有声明，无实现，因为native是用做Java和其他语言（如C++）进行协作时用的，也就是native后的函数的实现不是用java写的。</p>
<p>Thread类中有一个只有声明没有实现的方法，并使用<code>native</code>关键字，表示该方法是系统级（底层操作系统或第三方语言）的，而不是语言级的。</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200917160049799.png" class="">



<h3 id="五、PC寄存器"><a href="#五、PC寄存器" class="headerlink" title="五、PC寄存器"></a>五、PC寄存器</h3><p>PC寄存器（Program Counter Register）记录了方法之间的调用和执行情况。</p>
<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（<strong>用来存储指向下一条指令的地址，也就是即将要执行的指令代码</strong>），由执行引擎读取下一条指令。这块内存区域很小，几乎可以忽略不计（不存在GC）。它是<strong>当前线程所执行的字节码的行号指示器</strong>，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>如果执行的是一个<strong>native方法</strong>，那么这个<strong>计数器为空</strong>。因为native方法是通过其它语言来实现的，没有通过Java自然也就没有对应的字节码行号。</p>
<p>用来完成分支、循环、跳转、异常处理、线程恢复等基础功能，不会发生内存溢出（OutOfMemory——OOM）错误。</p>
<h3 id="六、方法区"><a href="#六、方法区" class="headerlink" title="六、方法区"></a>六、方法区</h3><p>供各线程共享的运行时内存区域。</p>
<p>它存储了每一个<strong>类的结构信息</strong>（模板），例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</p>
<p>方法区是一个<strong>规范</strong>，在不同虚拟机中的实现是不一样的，最典型的就是永久代（PermGen space）和元空间（Metaspace）。</p>
<p>实例变量存在堆内存中，和方法区无关。</p>
<h3 id="七、栈"><a href="#七、栈" class="headerlink" title="七、栈"></a>七、栈</h3><p><span style='color:red;'><strong>栈管运行，堆管存储</strong></span></p>
<p>栈也叫栈内存，主管Java程序的运行，在线程创建时创建。它的生命周期和线程一致，是线程私有的，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题。8种基本类型的变量、对象的引用变量、实例方法都是在函数的栈内存中分配。</p>
<h4 id="栈的存储内容"><a href="#栈的存储内容" class="headerlink" title="栈的存储内容"></a>栈的存储内容</h4><p>栈帧中主要保存3类数据</p>
<ul>
<li>本地变量（Local Variables）：输入参数和输出参数以及方法内的变量</li>
<li>栈操作（Operand Stack）：记录出栈、入栈的操作</li>
<li>栈帧数据（Frame Data）：包括类文件、方法等</li>
</ul>
<h4 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h4><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，……，执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……</p>
<p>遵循“先进后出/后进先出”原则。</p>
<p>每个方法执行的同时都会创建一个<strong>栈帧</strong>，用于<strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间，约等于1Mb左右。</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200918105002179.png" class="">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMNote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">        <span class="comment">//Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line">        <span class="comment">//这是个Error不是Exception</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h4><img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200918140159017.png" class="">

<p>HotSpot是使用指针的方式来访问对象：Java堆中会存放访问<strong>类元数据</strong>的地址，reference存储的是对象的地址</p>
<p>注：</p>
<ul>
<li>如果没有明确指明，JDK的名字就叫HotSpot</li>
<li>元数据：描述数据的数据，通俗一点，就是描述代码间关系，或者代码与其他资源（例如数据库表）之间内在联系的数据。</li>
</ul>
<h3 id="八、堆"><a href="#八、堆" class="headerlink" title="八、堆"></a>八、堆</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。堆内存分为三部分：</p>
<ul>
<li>新生区（Young/New Generation Space）</li>
<li>养老区（Tenure/Old Generation Space）</li>
<li>永久区（Permanent Space——Java 7之前）/ 元空间（Perm——Java 8之后）</li>
</ul>
<p>堆内存逻辑上分为三部分：新生、养老、永久/元空间，物理上分为两部分：新生、养老</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919145504023.png" class="">

<h4 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h4><p>新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（Survivor 0 Space，也叫From区）和1区（Survivor 1 Space，也叫To区）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸区中的不再被其它对象所引用的对象进行销毁，然后将伊甸区中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。如果1区也满了，再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现仍然无法进行对象的保存，就会产生OOM错误（“OutOfMemoryError”）。</p>
<p>如果出现“java.lang.OutOfMemoryError:Java heap space异常”，说明Java虚拟机的堆内存不够，原因有二：</p>
<ul>
<li>Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ul>
<h4 id="堆内存的划分"><a href="#堆内存的划分" class="headerlink" title="堆内存的划分"></a>堆内存的划分</h4><img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919163652763.png" class="">

<p>堆空间中，新生代占1/3，老年代占2/3；新生代中，Eden占8/10，From和To各占1/10</p>
<h4 id="Minor-GC过程"><a href="#Minor-GC过程" class="headerlink" title="Minor GC过程"></a>Minor GC过程</h4><p>复制→清空→互换</p>
<ul>
<li><p>Eden、From复制到To，年龄+1</p>
<p>首先，当Eden区满的时候会触发第一次GC，把还存活的对象拷贝到From区，当Eden区再次触发GC的时候会扫描Eden区和From区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象则直接复制到To区（如果有对象的年龄已经达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（分代年龄记录在对象头的MarkWorld中）。</p>
</li>
<li><p>清空Eden、From</p>
<p>然后，清空Eden区和From区中的对象。</p>
</li>
<li><p>To和From互换</p>
<p>最后，To和From互换，原To成为下一次GC时的From区。部分对象会在From和To区中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，默认值是<strong>15</strong>），最终如果还是存活，就存入到老年代。</p>
</li>
</ul>
<h4 id="永久代（JDK1-7之前）"><a href="#永久代（JDK1-7之前）" class="headerlink" title="永久代（JDK1.7之前）"></a>永久代（JDK1.7之前）</h4><p>方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的类信息、普通常量、静态常量、编译器编译后的代码等等。虽然JVM规范将方法去描述成堆的一个逻辑部分，但它还有一个别名叫Non-Heap（非堆），目的就是要和堆分开。</p>
<p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Permanent Gen）”，但从本质上说两者不同，或者说是使用永久代来实现方法区而已，永久代是方法区（相当于是一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代中的字符串常量池移走。</p>
<p>永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class、Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占用的内存。</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919172609276.png" class="">

<h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>在Java 8中，永久代已经被移除，被一个称为元空间的区域所取代，元空间的本质和永久代类似。</p>
<p>元空间和永久代之间最大的区别在于：<strong>永久代</strong>使用的是<strong>JVM的堆内存</strong>，但是Java 8以后的<strong>元空间</strong>并不在虚拟机中而是使用<strong>本机物理内存</strong>。</p>
<p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入native memory，字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>
<h3 id="九、堆参数调优"><a href="#九、堆参数调优" class="headerlink" title="九、堆参数调优"></a>九、堆参数调优</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xms</td>
<td align="center">设置JVM初始分配内存，默认为物理内存的1/64</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="center">设置JVM最大分配内存，默认为物理内存的1/4</td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDetails</td>
<td align="center">输出详细的GC处理日志</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();<span class="comment">//返回Java虚拟机试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();<span class="comment">//返回Java虚拟机中的内存总量</span></span><br><span class="line">        System.out.println(<span class="string">"-Xmx:MAX_MEMORY = "</span> + maxMemory + <span class="string">"（字节）、"</span> + (maxMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-Xms:TOTAL_MEMORY = "</span> + totalMemory + <span class="string">"（字节）、"</span> + (totalMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-Xmx:MAX_MEMORY = 3779067904（字节）、3604.0MB</span></span><br><span class="line"><span class="comment">-Xms:TOTAL_MEMORY = 255328256（字节）、243.5MB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>VM参数：<code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code></p>
<p>注：</p>
<ul>
<li><p>JVM参数调优，平时可以随意选择初始内存大小和最大内存大小，但在实际工作中，初始内存大小和最大内存大小应该是一致的，这样可以避免内存忽高忽低而产生的停顿</p>
</li>
<li><p>IDEA中设置VM参数：Run→Edit Configurations</p>
</li>
</ul>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919204406923.png" class="">

<h4 id="OOM演示"><a href="#OOM演示" class="headerlink" title="OOM演示"></a>OOM演示</h4><p>将VM参数的初始内存和最大内存分配都设置成10MB，执行下面的程序，就会报“java.lang.OutOfMemoryError: Java heap space”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();<span class="comment">//返回Java虚拟机试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();<span class="comment">//返回Java虚拟机中的内存总量</span></span><br><span class="line">        System.out.println(<span class="string">"-Xmx:MAX_MEMORY = "</span> + maxMemory + <span class="string">"（字节）、"</span> + (maxMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-Xms:TOTAL_MEMORY = "</span> + totalMemory + <span class="string">"（字节）、"</span> + (totalMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示OOM</span></span><br><span class="line"><span class="comment">//        byte[] bytes = new byte[40 * 1024 * 1024];//new大对象</span></span><br><span class="line">        String str = <span class="string">"www.atguigu.com"</span> ;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200919205653431.png" class="">

<h4 id="GC收集日志信息"><a href="#GC收集日志信息" class="headerlink" title="GC收集日志信息"></a>GC收集日志信息</h4><p>GC日志解读</p>
<ul>
<li><p>YoungGC</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200920103058010.png" class="">
</li>
<li><p>FullGC</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200920103243250.png" class="">

<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200920103315506.png" class="">
</li>
<li><p>规律</p>
<p>名称:GC前内存占用-&gt;GC后内存占用(该区内存总大小)</p>
</li>
</ul>
<h3 id="十、GC"><a href="#十、GC" class="headerlink" title="十、GC"></a>十、GC</h3><h4 id="GC介绍"><a href="#GC介绍" class="headerlink" title="GC介绍"></a>GC介绍</h4><p>GC垃圾收集机制（<u>分代收集算法</u>）</p>
<ul>
<li>次数上频繁收集新生代</li>
<li>次数上较少收集老年代</li>
<li>基本不动元空间</li>
</ul>
<p>JVM在进行GC时，并非每次都对堆内存区域一起回收，大部分时候回收的都是新生代。因此GC按照回收的区域又分为了两种类型，一种是普通GC（Minor GC），一种是全局GC（Major GC / Full GC）。</p>
<h4 id="Minor-GC和Full-GC的区别"><a href="#Minor-GC和Full-GC的区别" class="headerlink" title="Minor GC和Full GC的区别"></a>Minor GC和Full GC的区别</h4><p>普通GC（Minor GC）：只针对新生代区域的GC，发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所有Minor GC非常频繁，一般回收速度也比较快。</p>
<p>全局GC（Major GC / Full GC）：发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。</p>
<p>Major GC的速度一般要比Minor GC慢10倍以上，因为<strong>老年代区域比新生代区域大</strong>。</p>
<h4 id="GC四大算法"><a href="#GC四大算法" class="headerlink" title="GC四大算法"></a>GC四大算法</h4><ul>
<li><p>引用计数法</p>
<p>给每个对象设置一个计数器，当有地方引用这个对象时，计数器就+1；当引用失效时，计数器就-1；当计数器为0时，JVM就认为对象不再被引用，是垃圾了。</p>
<p>应用：微软的COM/ActionScrip3/Python…</p>
<p>优点：效率高</p>
<p>缺点：</p>
<ul>
<li>每次对对象赋值时都要维护引用计数器，且计数器本身也有一定的消耗</li>
<li>较难处理循环引用（如下）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ackage com.atguigu.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//此成员的唯一作用是占用一点内存</span></span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GCDemo demoA = <span class="keyword">new</span> GCDemo();</span><br><span class="line">        GCDemo demoB = <span class="keyword">new</span> GCDemo();</span><br><span class="line">        demoA.instance = demoB;</span><br><span class="line">        demoB.instance = demoA;</span><br><span class="line">        demoA = <span class="keyword">null</span>;</span><br><span class="line">        demoB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();<span class="comment">//执行此代码时，并非立刻开启GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM的实现一般不采用这种方式</p>
</li>
<li><p>复制算法（Copying）</p>
<p><strong>年轻代</strong>中使用的是Minor GC，这种GC算法采用的是复制算法。原理看第八节-Minor GC过程</p>
<p>优点：</p>
<ul>
<li>没有标记和清除的过程，效率高</li>
<li>不会产生内存碎片，可以利用bump-the-pointer实现快速内存分配</li>
</ul>
<p>缺点：</p>
<ul>
<li>浪费了一半的内存</li>
<li>如果对象的存活率很高（极端一点，假设是100%存活），那么需要将所有的对象都复制一遍，并将所有的引用地址重置一遍。复制工作所花费的时间在对象存活率达到一定程度时将会变的不可忽视。</li>
</ul>
<p>以上可以看出，复制算法要想使用，最起码<strong>对象的存活率要非常低</strong>才行，最重要的是必须要<strong>克服50%的内存浪费</strong>。</p>
</li>
<li><p>标记清除（Mark-Sweep）</p>
<p><strong>老年代</strong>一般是由<strong>标记清除</strong>或是<strong>标记清除与标记压缩</strong>（整理）的<strong>混合实现</strong></p>
<p>算法分为标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象。</p>
<p>在程序运行期间，当可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作，再让应用程序恢复运行。</p>
<p>优点：</p>
<ul>
<li>不需要额外空间</li>
</ul>
<p>缺点：</p>
<ul>
<li>两次扫描，耗时严重；效率比较低（递归与全栈对象遍历），而且在进行GC的时候，需要停止应用程序，用户体验差</li>
<li>会产生内存碎片</li>
</ul>
</li>
<li><p>标记压缩（Mark-Compact）</p>
<p>算法分为标记和压缩两个阶段。标记阶段和标记清除一样，在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。</p>
<p>标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p>优点：</p>
<ul>
<li>没有内存碎片，可以利用bump-the-pointer</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要移动对象的成本</li>
<li>效率不高（不仅要标记所有的存活对象，还要整理所有存活对象的引用地址。标记压缩算法的效率要低于复制算法）</li>
</ul>
<p>标记清除压缩（Mark-Sweep-Compact）</p>
<ul>
<li>Mark-Sweep和Mark-Compact的结合</li>
<li>和Mark-Sweep一致，当进行多次GC后才Compact</li>
</ul>
</li>
<li><p>总结：</p>
<p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（此处只是简单的对比时间复杂度，实际情况不一定如此）</p>
<p>内存整齐度：复制算法=标记压缩算法&gt;标记清除算法</p>
<p>内存利用率：标记整理算法=标记清除算法&gt;复制算法</p>
</li>
<li><p>没有最好的算法，只有最合适的算法——分代收集算法</p>
<p>年轻代（Young Gen）：年轻代的特点是区域相对老年代较小，对象存活率低。</p>
<p>这种情况复制算法的回收整理速度是最快的，复制算法的效率只和当前存活对象的大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过HotSpot中的两个survivor的设计得到缓解。</p>
<p>老年代（Tenure Gen）：老年代的特点是区域较大，对象存活率高。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显不合适，一般是由标记清除或者是标记清除与标记压缩的混合实现。</p>
</li>
</ul>
<p>  Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</p>
<p>  Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</p>
<p>  Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</p>
<p>  基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<h3 id="十一、JMM"><a href="#十一、JMM" class="headerlink" title="十一、JMM"></a>十一、JMM</h3><h4 id="JMM介绍"><a href="#JMM介绍" class="headerlink" title="JMM介绍"></a>JMM介绍</h4><p>JMM（Java内存模型：Java Memory Model）本身是一种抽象的概念，并不是真实存在的，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>
<h4 id="JMM关于同步的规定"><a href="#JMM关于同步的规定" class="headerlink" title="JMM关于同步的规定"></a>JMM关于同步的规定</h4><ul>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>
<li>加锁解锁是同一把锁</li>
</ul>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个<strong>工作内存</strong>（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，<strong>首先要将变量从主内存拷贝到线程的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存中<strong>变量的副本拷贝</strong>，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下：</p>
<img src="/2020/09/16/JVM%E5%9F%BA%E7%A1%80/image-20200921195758140.png" class="">


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/17/MyBatis/" rel="prev" title="MyBatis">
      <i class="fa fa-chevron-left"></i> MyBatis
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、JVM位置"><span class="nav-number">1.</span> <span class="nav-text">一、JVM位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、类装载器"><span class="nav-number">2.</span> <span class="nav-text">二、类装载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是类装载器"><span class="nav-number">2.1.</span> <span class="nav-text">什么是类装载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类装载器的分类"><span class="nav-number">2.2.</span> <span class="nav-text">类装载器的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派"><span class="nav-number">2.3.</span> <span class="nav-text">双亲委派</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、执行引擎"><span class="nav-number">3.</span> <span class="nav-text">三、执行引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、本地方法接口与本地方法栈"><span class="nav-number">4.</span> <span class="nav-text">四、本地方法接口与本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、PC寄存器"><span class="nav-number">5.</span> <span class="nav-text">五、PC寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、方法区"><span class="nav-number">6.</span> <span class="nav-text">六、方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、栈"><span class="nav-number">7.</span> <span class="nav-text">七、栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的存储内容"><span class="nav-number">7.1.</span> <span class="nav-text">栈的存储内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的运行原理"><span class="nav-number">7.2.</span> <span class="nav-text">栈的运行原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈、堆、方法区的交互关系"><span class="nav-number">7.3.</span> <span class="nav-text">栈、堆、方法区的交互关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、堆"><span class="nav-number">8.</span> <span class="nav-text">八、堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的生命周期"><span class="nav-number">8.1.</span> <span class="nav-text">对象的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆内存的划分"><span class="nav-number">8.2.</span> <span class="nav-text">堆内存的划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC过程"><span class="nav-number">8.3.</span> <span class="nav-text">Minor GC过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#永久代（JDK1-7之前）"><span class="nav-number">8.4.</span> <span class="nav-text">永久代（JDK1.7之前）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元空间"><span class="nav-number">8.5.</span> <span class="nav-text">元空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、堆参数调优"><span class="nav-number">9.</span> <span class="nav-text">九、堆参数调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本参数"><span class="nav-number">9.1.</span> <span class="nav-text">基本参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OOM演示"><span class="nav-number">9.2.</span> <span class="nav-text">OOM演示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC收集日志信息"><span class="nav-number">9.3.</span> <span class="nav-text">GC收集日志信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、GC"><span class="nav-number">10.</span> <span class="nav-text">十、GC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC介绍"><span class="nav-number">10.1.</span> <span class="nav-text">GC介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC和Full-GC的区别"><span class="nav-number">10.2.</span> <span class="nav-text">Minor GC和Full GC的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC四大算法"><span class="nav-number">10.3.</span> <span class="nav-text">GC四大算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一、JMM"><span class="nav-number">11.</span> <span class="nav-text">十一、JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM介绍"><span class="nav-number">11.1.</span> <span class="nav-text">JMM介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM关于同步的规定"><span class="nav-number">11.2.</span> <span class="nav-text">JMM关于同步的规定</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Leo-Fang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Leo-Fang</p>
  <div class="site-description" itemprop="description">记录学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Leo-Fang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leo-Fang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lefang0530@gmail.com" title="E-Mail → mailto:lefang0530@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo-Fang</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共134.8k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'V6ESupTFrlogGO5niagnkvsh-gzGzoHsz',
      appKey     : 'aA5SS2K4SpyjvaSTnAUoxupj',
      placeholder: "ฅ՞•ﻌ•՞ฅ来唠唠嗑呗~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
